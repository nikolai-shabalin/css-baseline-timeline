---
import FeatureList from '../components/FeatureList.astro';
import { fetchTimelineData } from '../lib/rss';
import '../styles/global.css';

const { widelyAvailable, newlyAvailable } = await fetchTimelineData();

const dateFormatter = new Intl.DateTimeFormat('ru-RU', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

const buildTimestamp = new Date();
const buildTimestampISO = buildTimestamp.toISOString();
const buildTimestampLabel = dateFormatter.format(buildTimestamp);
---

<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSS Baseline Timeline</title>
    <meta name="description" content="Две подборки CSS‑свойств из Baseline: widely available и newly available. Актуально, дерзко, вдохновлено Артёмом Лебедевым." />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body id="top">
    <main>
      <header class="page-header">
        <h1 class="page-title">
          <span>CSS</span>
          <strong>Baseline</strong>
          <span>Timeline</span>
        </h1>
        <p class="page-subtitle">
          Отслеживайте, какие CSS‑возможности уже доступные везде, а какие только что вошли в
          Baseline. Это витрина прогресса, собранная из официальных RSS‑лент Web Platform DX.
        </p>
        <div class="page-meta">
          <span>последняя проверка:</span>
          <time datetime={buildTimestampISO}>{buildTimestampLabel}</time>
        </div>
        <div class="legend">
          <span>
            <span class="legend-indicator legend-indicator--widely"></span>
            Widely available
          </span>
          <span>
            <span class="legend-indicator legend-indicator--newly"></span>
            Newly available
          </span>
        </div>
      </header>

      <div class="page-search">
        <input
          type="search"
          class="page-search__input"
          placeholder="Поиск по названию..."
          aria-label="Поиск по названию свойств"
          id="global-search"
        />
      </div>

      <section class="lists">
        <FeatureList title="Везде поддерживается" features={widelyAvailable} accent="widely" />
        <FeatureList title="Только что достигло Baseline" features={newlyAvailable} accent="newly" />
      </section>
    </main>
    
    <a href="#top" class="back-to-top" aria-label="Наверх">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M7 14L12 9L17 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </a>

    <script>
      (function() {
        const searchInput = document.getElementById('global-search') as HTMLInputElement | null;
        
        if (!searchInput) return;

        function filterFeatures(searchTerm: string) {
          const searchLower = searchTerm.toLowerCase().trim();
          const allFeatureCards = document.querySelectorAll('.feature-card') as NodeListOf<HTMLElement>;
          const allGroups = document.querySelectorAll('.feature-group') as NodeListOf<HTMLElement>;
          const allFeatureLists = document.querySelectorAll('.feature-list') as NodeListOf<HTMLElement>;
          
          // Фильтруем все карточки на странице
          allFeatureCards.forEach((card) => {
            const titleElement = card.querySelector('.feature-card__title');
            const title = titleElement ? (titleElement.textContent || '').toLowerCase() : '';
            const matches = searchLower === '' || title.includes(searchLower);
            
            if (matches) {
              card.style.display = '';
            } else {
              card.style.display = 'none';
            }
          });
          
          // Скрываем группы, в которых нет видимых элементов
          allGroups.forEach((group) => {
            const visibleCards = group.querySelectorAll('.feature-card:not([style*="display: none"])');
            const groupHeader = group.querySelector('.feature-group__header');
            
            if (visibleCards.length === 0 && searchLower !== '') {
              group.style.display = 'none';
            } else {
              group.style.display = '';
              if (groupHeader) {
                const countSpan = groupHeader.querySelector('.feature-group__count');
                if (countSpan) {
                  // Восстанавливаем оригинальный счетчик или показываем отфильтрованный
                  const originalCount = countSpan.getAttribute('data-original-count');
                  if (searchLower === '') {
                    if (originalCount) {
                      countSpan.textContent = originalCount;
                    }
                  } else {
                    countSpan.textContent = String(visibleCards.length);
                  }
                }
              }
            }
          });

          // Скрываем списки, в которых нет видимых элементов
          allFeatureLists.forEach((list) => {
            const visibleCards = list.querySelectorAll('.feature-card:not([style*="display: none"])');
            const countElement = list.querySelector('.feature-list__count span');
            
            if (countElement) {
              if (searchLower === '') {
                const originalCount = countElement.getAttribute('data-original-count');
                if (originalCount) {
                  countElement.textContent = originalCount;
                }
              } else {
                countElement.textContent = String(visibleCards.length);
              }
            }
          });
        }

        // Сохраняем оригинальные счетчики при загрузке и применяем фильтр из query
        document.addEventListener('DOMContentLoaded', () => {
          document.querySelectorAll('.feature-group__count').forEach((count) => {
            if (!count.getAttribute('data-original-count')) {
              count.setAttribute('data-original-count', count.textContent || '');
            }
          });
          document.querySelectorAll('.feature-list__count span').forEach((count) => {
            if (!count.getAttribute('data-original-count')) {
              count.setAttribute('data-original-count', count.textContent || '');
            }
          });

          // Если есть параметр ?property= в URL — применяем его к поиску
          const params = new URLSearchParams(window.location.search);
          const propertyQuery = params.get('property');
          if (propertyQuery) {
            searchInput.value = propertyQuery;
            filterFeatures(propertyQuery);
          }
        });

        // Debounce функция для задержки поиска
        let searchTimeout: ReturnType<typeof setTimeout> | undefined;
        searchInput.addEventListener('input', () => {
          // Очищаем предыдущий таймер, если он существует
          if (searchTimeout) {
            clearTimeout(searchTimeout);
          }
          
          // Устанавливаем новый таймер на 300ms
          // Поиск выполнится только через 300ms после последнего ввода
          searchTimeout = setTimeout(() => {
            filterFeatures(searchInput.value);
          }, 300);
        });

        // Клик по # рядом с названием: обновляет URL, фильтр и копирует ссылку
        document.addEventListener('click', async (event) => {
          const target = event.target as HTMLElement | null;
          const anchor = target?.closest('[data-property-link]') as HTMLElement | null;
          if (!anchor) return;

          event.preventDefault();

          const propertyName = anchor.getAttribute('data-property-link') || '';
          if (!propertyName) return;

          const newUrl = new URL(window.location.href);
          newUrl.searchParams.set('property', propertyName);

          // Обновляем адресную строку без перезагрузки
          window.history.replaceState({}, '', newUrl);

          // Обновляем поле поиска и фильтрацию
          searchInput.value = propertyName;
          filterFeatures(propertyName);

          // Копируем ссылку в буфер обмена
          try {
            await navigator.clipboard.writeText(newUrl.toString());
          } catch (err) {
            console.error('Не удалось скопировать ссылку', err);
          }
        });
      })();
    </script>
  </body>
</html>
